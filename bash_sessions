#!/bin/bash
IFS=$'\n\t'

# bash_sessions - Session manager for the Bash shell
#
# Copyright (C) 2016 Alessandro Grassi <alessandro.g89@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

BASH_SESSIONS_DIR="$HOME/.bash_sessions"
BASH_SESSIONS_TEMP_DIR="/tmp/.bash_sessions/"
BASH_SESSIONS_MAXIMUM_OUTPUT_LINES="1000"


__bs_savepwd(){
	# check that we are inside a session
	[ -z "$BASH_SESSION_NAME" ] && return
	
	# check that the target directory exists
	[ -d "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}" ] || return
	
	# save current working directory to a file
	if [ "$PWD" != "$PREV_PWD" ]; then
		PREV_PWD="$PWD"
		echo "$PWD" > "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/pwd"
	fi
}

# save changes to the environment
__bs_saveenv(){
	# check that we are inside a session
	[ -z "$BASH_SESSION_NAME" ] && return
	
	# check that the target directory exists
	[ -d "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}" ] || return
	
	# check that temp dir exists
	[ -d "${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}" ] || mkdir -p "${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}"
	
	# save changes to the environment in a file
	cat "/proc/$$/environ" | tr '\0' '\n' | sort | grep "=" > "${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}/initial_env"
	env | sort | grep "=" > "${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}/current_env"
	diff --new-line-format=%L --old-line-format= --unchanged-line-format= \
		"${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}/initial_env" \
		"${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}/current_env" \
		| egrep -v "(^PATH=|^PROMPT_COMMAND=|^SHLVL=|^COMP_WORDBREAKS=|^PWD=|^_=)" > "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/env_changed"
	diff --new-line-format= --old-line-format=%L --unchanged-line-format= \
		"${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}/initial_env" \
		"${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}/current_env" \
		| egrep -v "(^PATH=|^SHLVL=|^COMP_WORDBREAKS=|^PWD=|^_=)" | cut -d = -f 1 > "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/env_deleted"
}

# create and activate a new session
n (){
	# check number of arguments
	if [ "$#" -ne 1 ]; then
		echo "Error: ${FUNCNAME[0]}() requires exactly 1 argument"
		return
	fi
	
	# create sessions directory if needed
	[ -d "${BASH_SESSIONS_DIR}" ] || mkdir -p "${BASH_SESSIONS_DIR}"
	
	# check session not existing already
	if [ -d "${BASH_SESSIONS_DIR}/${1}" ]; then
		echo "Error: session \"${1}\" already exists"
		return
	fi
	
	# quit current session, if any
	if [ -n "$BASH_SESSION_NAME" ]; then
		echo "Error: close current session first"
		return
	fi
	
	# create directory for new session
	[ -d "${BASH_SESSIONS_DIR}/${1}" ] || mkdir -p "${BASH_SESSIONS_DIR}/${1}"
	
	# copy last part of current history to new session
	tail -n 100 "${HISTFILE}" > "${BASH_SESSIONS_DIR}/${1}/history"
	
	# activate new session
	o "${1}"
}

# activate an existing session
o (){
	# check number of arguments
	if [ "$#" -ne 1 ]; then
		echo "Error: ${FUNCNAME[0]}() requires exactly 1 argument"
		return
	fi
	
	# create sessions directory if needed
	[ -d "${BASH_SESSIONS_DIR}" ] || mkdir -p "${BASH_SESSIONS_DIR}"
	
	# check that session exists
	if ! [ -d "${BASH_SESSIONS_DIR}/$1" ]; then
		echo "Error: session \"$1\" does not exist"
		return
	fi
	
	# quit current session, if any
	[ -n "$BASH_SESSION_NAME" ] && c
	
	# check that the session is not already in use
	if lsof "${BASH_SESSIONS_DIR}/$1/output" &> /dev/null; then
		echo "Error: session \"$1\" is already in use!"
		return
	fi
	
	# set session name
	export BASH_SESSION_NAME="${1}"
	
	# check that temp dir exists
	[ -d "${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}" ] || mkdir -p "${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}"
	
	# create script to activate session
	echo '[ -f /etc/bash.bashrc ] && . /etc/bash.bashrc'  > "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	echo '[ -f ~/.bashrc ] && . ~/.bashrc' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	
	# switch to dedicated history file
	echo 'history -c' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	echo 'export HISTFILE="${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/history"' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	
	# add newline to output if needed
	[ -f "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/loaded" ] && echo >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output"
	
	# switch to working directory
	[ -f "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/pwd" ] && echo 'cd "$(cat "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/pwd")"' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	
	# load old output from file
	if [ -f "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output" ]; then
		if [ $(wc -l "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output" | cut -f 1 -d " ") -ge ${BASH_SESSIONS_MAXIMUM_OUTPUT_LINES} ]; then
			tail -n ${BASH_SESSIONS_MAXIMUM_OUTPUT_LINES} "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output" > "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output.tail"
			mv "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output.tail" "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output"
		fi
		cat "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output"
	fi
	
	# mark session as loaded
	touch "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/loaded"
	
	# set prompt command to save working directory and environment
	echo 'export PROMPT_COMMAND="${PROMPT_COMMAND};__bs_savepwd;__bs_saveenv"' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	
	# restore environment
	echo '[ -f "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/env_changed" ] && while read line; do' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	echo '	export $line;' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	echo 'done < "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/env_changed"' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	echo '[ -f "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/env_deleted" ] && while read line; do' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	echo '	unset $line;' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	echo 'done < "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/env_deleted"' >> "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc"
	
	# the session is executed inside script, to save the output to a file
	script -a -q "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output" -c "bash --rcfile \"${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/bashrc\""
	
	#everything that follows happens after the session is closed
	
	# delete temporary files
	rm -f "${BASH_SESSIONS_TEMP_DIR}/${BASH_SESSION_NAME}/"*
	
	# limit the length of saved output
	if [ $(wc -l "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output" | cut -f 1 -d " ") -ge ${BASH_SESSIONS_MAXIMUM_OUTPUT_LINES} ]; then
		tail -n ${BASH_SESSIONS_MAXIMUM_OUTPUT_LINES} "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output" > "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output.tail"
		mv "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output.tail" "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/output"
	fi
	
	# mark session as unloaded
	[ -f "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/loaded" ] && rm -f "${BASH_SESSIONS_DIR}/${BASH_SESSION_NAME}/loaded"
	unset BASH_SESSION_NAME
	
}

# exit active session
c (){
	# check number of arguments
	if [ "$#" -ne 0 ]; then
		echo "Error: ${FUNCNAME[0]}() does not accept arguments"
		return
	fi
	
	# check that we are in a session
	if [ -z "$BASH_SESSION_NAME" ]; then
		echo "No session active!"
		return
	fi
	
	exit &>/dev/null

}

# delete an existing session
f (){
	# check number of arguments
	if [ "$#" -ne 1 ]; then
		echo "Error: ${FUNCNAME[0]}() requires exactly 1 argument"
		return
	fi
	
	# check that we are not in a session
	if [ -n "$BASH_SESSION_NAME" ]; then
		echo "Exit current session first!"
		return
	fi
	
	# check if session exists
	if ! [ -d "${BASH_SESSIONS_DIR}/$1" ]; then
		echo "Session \"$1\" does not exist!"
		return
	fi
	
	# ask confirmation and delete session
	read -p "Delete session \"$1\"? [yN] " -n 1 -r
	echo
	if [[ $REPLY =~ ^[Yy]$ ]]; then
		rm -f -r "${BASH_SESSIONS_DIR}/$1"
		echo "Session \"$1\" deleted"
	fi
}

# rename an existing session
r (){
	# check number of arguments
	if [ "$#" -ne 2 ]; then
		echo "Error: ${FUNCNAME[0]}() requires exactly 2 arguments"
		return
	fi
	
	# check that we are not in a session
	if [ -n "$BASH_SESSION_NAME" ]; then
		echo "Exit current session first!"
		return
	fi
	
	# check if session exists
	if ! [ -d "${BASH_SESSIONS_DIR}/$1" ]; then
		echo "Session \"$1\" does not exist!"
		return
	fi
	
	mv "${BASH_SESSIONS_DIR}/$1" "${BASH_SESSIONS_DIR}/$2"
	echo "Session \"$1\" renamed to \"$2\""
}

# re-open all session which were not explicitly closed
a (){
	for SESSION_NAME in $(ls "${BASH_SESSIONS_DIR}"); do
		if [ -f "${BASH_SESSIONS_DIR}/${SESSION_NAME}/loaded" ]; then
			if ! lsof "${BASH_SESSIONS_DIR}/${SESSION_NAME}/output"; then
				echo "Loading session \"${SESSION_NAME}\""
				
				local temp_rc_file="/tmp/.bash_session_rc_${SESSION_NAME}"
				local temp_desktop_file="$HOME/.local/share/applications/bash-session-${SESSION_NAME}.desktop"
				
				echo ". ~/.bashrc" > "${temp_rc_file}"
				echo "o ${SESSION_NAME}" >> "${temp_rc_file}"
				echo "rm -f \"${temp_rc_file}\"" >> "${temp_rc_file}"
				echo "rm -f \"${temp_desktop_file}\"" >> "${temp_rc_file}"
				
				echo "[Desktop Entry]" > "${temp_desktop_file}"
				echo "Exec=x-terminal-emulator -x bash --rcfile ${temp_rc_file}" >> "${temp_desktop_file}"
				echo "Type=Application" >> "${temp_desktop_file}"
				
				gtk-launch "bash-session-${SESSION_NAME}.desktop"
				sleep 0.1
			fi
		fi
	done
}

# print label for bash prompt
__bs_ps1 (){
	if [ -n "$BASH_SESSION_NAME" ]; then
		echo "[$BASH_SESSION_NAME]"
	else
		echo ""
	fi
}

# list sessions
function e {
	
	# create sessions directory if needed
	[ -d "${BASH_SESSIONS_DIR}" ] || mkdir -p "${BASH_SESSIONS_DIR}"
	
	for i in $(ls ${BASH_SESSIONS_DIR}); do
		if [ -f "${BASH_SESSIONS_DIR}/${i}/loaded" ]; then
			if lsof "${BASH_SESSIONS_DIR}/${i}/output" &>/dev/null; then
				echo "${i}*"
			else
				echo "${i}+"
			fi
		else
			echo "${i}"
		fi;
	done
}

# helper function for completion
function __bs_comp_list {
	
	# create sessions directory if needed
	[ -d "${BASH_SESSIONS_DIR}" ] || mkdir -p "${BASH_SESSIONS_DIR}"
	
	ls "${BASH_SESSIONS_DIR}"
}

# completion command
function _bash_session_comp {
	local curw
	COMPREPLY=()
	curw=${COMP_WORDS[COMP_CWORD]}
	COMPREPLY=($(compgen -W '`__bs_comp_list`' -- $curw))
	return 0
}


# bind completion command for o, f, r to _comp
shopt -s progcomp
complete -o filenames -F _bash_session_comp o
complete -o filenames -F _bash_session_comp f
complete -o filenames -F _bash_session_comp r

